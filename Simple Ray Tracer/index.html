<!-- Arda Turkoglu - 21601187
     Irem Kırmacı - 21501389

    Texture mapping and shader information is referenced from : 
    https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms
    https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html 

    intersectionPoints referenced from:
    https://lousodrome.net/blog/light/2017/01/03/intersectionPoint-of-a-ray-and-a-cone/
    https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersectionPoint
    
    Intersections and techniques:
    http://groups.csail.mit.edu/graphics/classes/6.837/F99/assignment6/ivray/RayCast.C
    http://madebyevan.com/webgl-path-tracing/

    Slides


-->
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <title>Ray tracing application</title>

    <script id="vertex-shader" type="x-shader/x-vertex" >
        attribute vec4 vPosition;

        void main() 
        {
            gl_Position = vPosition;
        } 
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;     
uniform vec4 backGround;   
//Map object data to textures.   
uniform sampler2D objects;	
//Object Positions.	
uniform sampler2D positions;	
//Object Colors.	
uniform sampler2D colors;		
//Object materials.    
uniform sampler2D materials;	
//Light positions.
uniform sampler2D lightPositions;
//Light colors.		
uniform sampler2D lightColors;    
           
uniform int numObjects;
uniform float objectTextureSize;
uniform int numLights;
uniform float lightTextureSize;


//Convert all coordinates to texture system x,y = [0,1][0,1]
vec2 convertTexCoord(in int objectID, in int numberObjects, in float textureSize) {
   if(numberObjects == 1)
        return vec2(0.5, 0.5);

    float z = 0.0;    
   float col = mod (float(objectID) + 0.1, textureSize+z ) ;
   float x =  col * (1.0 / textureSize) + ((1.0 / textureSize+z) / 2.0);
   
   int row = int(float(objectID) / textureSize+z);
   float y =  float(row) * (1.0 / textureSize+z) + ((1.0 / textureSize+z) / 2.0);
   
    return vec2(x, y);
}

//discriminant calculation
float calculateDiscriminant(float a,float b,float c)
{
    return b * b - 4.0 *a* c;
}
    
//intersection of the sphere and its points and informations about

bool calc_Intersect_sphere( int sphereTexture,  vec3 origin,  vec3 direction, inout float originToIntersect, inout int closestObject ) {
    
    bool hitSphere = true;

    //Convert to texel first.
    vec4 sphere = texture2D(positions, convertTexCoord(sphereTexture, numObjects, objectTextureSize));
    vec3 position = sphere.xyz;
    float radius = sphere.w;
    
    //Calculate distance between center and ray origin.
    vec3 distance = origin - position;
    float originToCenter = dot(direction,distance );


    // discirimination calculation
    //Unit vector.
    float a = 1.0; 

    float b = 2.0 * originToCenter;

    //dor production
    float c = dot( distance, distance ) - radius * radius;   

    float discriminantSphere = calculateDiscriminant(a,b,c);
    //Root from the discriminant(intersectionPointPoint)
    float root = (-b - sqrt(discriminantSphere)) / 2.0*a; 
    
    //Checking of the hitSphere boolean
    // If discriminantSphere < 0 , ray does not hit sphere.
    if(discriminantSphere < 0.0)
        hitSphere = false; //turn to false
    
    //If discriminatSphere >= 0, control the root 
    //if root >0 hit is again false
    else if(root < 0.0  )
        hitSphere = false;
    //if root > originToIntersect hitSphere is again false
    else if(root >originToIntersect) 
        hitSphere = false;

    if(hitSphere)
    {
    originToIntersect = root;
    //Intersected Sphere
    closestObject = sphereTexture;
    }
    return hitSphere;
}

// Intersection of Cube and its points,info etc.
//Incompleted :(
bool calc_Intersect_cube(in int cubeTexture, in vec3 origin, in vec3 direction, inout float originToIntersect, inout int closestObject ) {
    
    vec4 cube = texture2D(positions, convertTexCoord(cubeTexture, numObjects, objectTextureSize));
    vec3 center = cube.xyz;
    float length = cube.w;

    vec3 minDistance = (cube.xyz- cube.w + origin)/direction;
    vec3 maxDistance = (cube.xyz- cube.w - origin)/direction;

   float near = max(minDistance.x,minDistance.z);
   float far = min(minDistance.x,minDistance.z);

   

   if(near > far)
    return false;
    else
    {

        originToIntersect = near;
        //Intersected Cube
        closestObject = cubeTexture;
    }

    return true;
}
// Intersection of Cone and its points,info etc.
//Incompleted :(
bool calc_Intersect_cone(in int coneTexture, in vec3 origin, in vec3 direction, inout float originToIntersect, inout int closestObject ) {
 
    vec4 cone = texture2D(positions, convertTexCoord(coneTexture, numObjects, objectTextureSize));
    vec3 center = cone.xyz;

    vec3 tipPosition = vec3(cone.x,cone.y,cone.w);
    vec3 tipToOrigin = origin - tipPosition;
    float tipToOriginAxis = dot(direction,tipToOrigin);

    vec3 distance = origin - center;
    float originToCenter = dot(direction,distance );

    float cosa = 0.0;// cos(30); //Need to be fixed.

    
    float a = dot(direction ,direction) -(cosa *cosa);
    float b = 2.0 *(tipToOriginAxis-originToCenter)*cosa*cosa;
    float c = tipToOriginAxis * (tipToOriginAxis-dot(tipToOrigin,tipToOrigin)) * cosa *cosa;


    float discriminant = calculateDiscriminant(a,b,c);
    if (discriminant < 0.0)
        return false;
    float root1 = (-b - sqrt(discriminant)) / 2.0*a;
    float root2 = (-b + sqrt(discriminant)) / 2.0*a;

    float intersectionRoot = root1;

    if(root1 < 0.0 || root2 > 0.0 && root2 < root1)
        {
            originToIntersect = root2;
    //Intersected Cone
    closestObject = coneTexture;
        }
        

    return true;
    
}

//Finding the closest interseciton

bool closestIntersect(in vec3 origin, in vec3 direction, inout float originToIntersect, inout int closestObject){
    bool hit = false;
   
    // Hit all  objects in the scene to check if there is a hit. ( max 32)
    for(int object_counter = 0; object_counter < 32; object_counter++) {
        
        
        if( object_counter >= numObjects ) 
        break;
            
        // Get object type   
        vec2 texelCoordinates = convertTexCoord(object_counter, numObjects, objectTextureSize);

        // get the first attiribute of the object.
        int objectType = int( texture2D( objects, texelCoordinates ).y * 256.0 ); 
        
        //TO DO***********************************
        //the only sphere was implemented, therefore,only first if is working
        if(objectType == 0) {
            if (calc_Intersect_sphere( object_counter, origin, direction, originToIntersect, closestObject ))
                hit = true;
        }
        else if(objectType == 1) {
            if (calc_Intersect_cube( object_counter, origin, direction, originToIntersect, closestObject ))
                hit = true;
        }
        else if(objectType == 2) {
            if (calc_Intersect_cone( object_counter, origin, direction, originToIntersect, closestObject ))
                hit = true;
        }
         
    }
    
    return hit;
}
//SHADE      
vec4 shade(in vec3 origin, in vec3 direction, in float originToIntersect, in int closestObject) {
    //TO DO
    //Phong Model was used 

    vec2 texCoord = convertTexCoord( closestObject , numObjects, objectTextureSize);
    //ıntersection point of the current object.
    vec3 intersectionPoint = origin + direction * originToIntersect;
    //Initial values for the closest object.
    float closestShadowDistance = 5000.0;        
    int closestShadowObjectID = -2;
    
    //The intial ambient color 
    vec4 sceneLightColor = vec4(0.1, 0.0, 0.0, 5.0) + vec4(0.4, 0.4, 0.4, 1.0) * texture2D(materials, convertTexCoord(closestObject, numObjects, objectTextureSize)).z;
    
    // Check all lights to shade object.
    // (max number of the light number is 5
    for(int i = 0; i < 5; i++) {
        
        if(i >= numLights) 
        break;
        
        /// Compute light
        // Get position of light
        vec2 lightTexelCoord = convertTexCoord(i, numLights, lightTextureSize);
        vec3 lightPosition = texture2D( lightPositions, lightTexelCoord ).xyz;
     
       
        // If ray does not hit anything in the direction of it do not give any color value.
        if( !closestIntersect(intersectionPoint - normalize( lightPosition - intersectionPoint ) * 0.03, normalize( lightPosition - intersectionPoint ), closestShadowDistance, closestShadowObjectID )) {
            
            //TO DO
            //Light coeffiecient changes according to the distance decreases with the square of the distance between light and object.
            //If light moves from the object calculate the coefficients for distance.                
            float lightDistanceFactor = 1.0 / ( .2 + .1 * distance(intersectionPoint, lightPosition) + .5 * distance(intersectionPoint, lightPosition) * distance(intersectionPoint, lightPosition));
           
            //Diffuse component of the object.
            float diffuseReflectionCoefficient = texture2D(materials, convertTexCoord(closestObject, numObjects, objectTextureSize)).y; // See light definition
            vec3 normalOfObject = normalize( intersectionPoint - texture2D( positions, texCoord ).xyz );
            
            //diffuse light parameter of the light according to the light's angle.
            float angleDiffuse = 0.0;
            if(dot(normalOfObject, normalize( lightPosition - intersectionPoint )) >= 0.0) 
                angleDiffuse =dot(normalOfObject, normalize( lightPosition - intersectionPoint ));
            else
                angleDiffuse = 0.0;
                                
            
            // Specular light formula
            //Get specular component from the closest object.
            float specularReflectionCoefficient = texture2D(materials, convertTexCoord(closestObject, numObjects, objectTextureSize)).x;
                                
            //Reflect specular around normal of the object.
            vec3 specularReflection = normalize( ( normalize( lightPosition - intersectionPoint ) - direction) / length(normalize( lightPosition - intersectionPoint ) - direction));
            //shiness of specular, reflection coeffiecient = 40.
            float specularResult = specularReflectionCoefficient * pow(max( dot(normalOfObject, specularReflection), 0.0), 40.0);
           
            //Final color according to the Phong light formula.
            sceneLightColor = sceneLightColor + (lightDistanceFactor * texture2D( lightColors, lightTexelCoord ) * (diffuseReflectionCoefficient * angleDiffuse + specularResult));                     
            
        }         
    }
    
    return sceneLightColor;
    
}
//Trace
//Cast ray from eye and trace it along direction.
// Recursive method to add color of reflected rays 
vec4 trace(in vec3 origin, in vec3 direction){
    
    //declarations
    vec2 texCoord ;
    vec4 color ;

    // After each ray bounce fractate the color by 0.1
    float fractionColor =1.0; 
    vec4 finalColor; 
    for (int rays = 0; rays < 2; rays++) {
        
        // Prepare to intersect world
        float originToIntersect = 99999.0;
        int closestObject = -9999;
        
       
        //Find the closest intersection with the closestIntersect function
        if( closestIntersect( origin, direction, originToIntersect, closestObject ) ){             
            
            // Map object to the tex coordinates.
            texCoord = convertTexCoord( closestObject , numObjects, objectTextureSize);
            
            //Shade the intersected object.
            color = shade( origin, direction, originToIntersect, closestObject );                    
            // Apply color to the object with its current color.
            color = mix( color, texture2D(colors, texCoord), 0.51 );
            
        } else {
            //We could not hit anything for this direction.
            color = backGround;
        }
       //Add calculated color to the final color.
        finalColor = finalColor + color*fractionColor ;
        fractionColor = fractionColor*0.09;

        //Reflection vector equation = Direction − 2*Normal*(Direction . Normal), 
        // Update origin and direction
        
        origin += direction * (originToIntersect - .02);
        vec3 normalOfObject = normalize( origin - texture2D( positions, texCoord ).xyz );
        //Direction of the reflected ray. (Reverse of the angle between normal and direction.)
        direction = direction - 2.0 * normalOfObject * dot( direction, normalOfObject ); //Triangle and angle equation. ??
    }   
    
    
    return finalColor;
}

//THE RAY CASTING    
void main() {
     
    vec3 origin = texture2D(lightPositions, convertTexCoord(0, numLights, lightTextureSize)).xyz;

    // Direction of the ray from camera to objects
    //gl_FragCoord.xy is screen space coordinates of current pixel based on viewport size.
    //Normalize to -1,1
    
    vec3 direction = normalize(vec3(( gl_FragCoord.xy / vec2(512,512) - 0.5)  * 1.0, 1.0));
    
    //Each time origin changed, call trace for the new location.
    gl_FragColor = trace(origin, direction);
}
        

        
    </script>
    <!--tTHE BOOTSTRAP WAS USED TO HAVE BETTER USER INTERFACE -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">

    <script type="text/javascript" src="./Common/webgl-utils.js"></script>
    <script type="text/javascript" src="./Common/initShaders.js"></script>
    <script type="text/javascript" src="./Common/MV.js"></script>
    <script type="text/javascript" src="hw3.js"></script>
</head>  
<h1>RAY TRACING</h1>

    <body>
        <div class="container">
        <div class="row">
            
            <div class="col">
                <canvas id="gl-canvas" width="512" height="512">
                    Oops ... your browser doesn't support the HTML5 canvas element
                </canvas>
            </div>

             <!--the column of information of sphere is taking from the user -->
            <div class="col">
                <div class="p-3 mb-2 bg-info text-dark">Set Coordinates</div>
               <!--COORDINATES -->
                <div>
                    <p> <mark>X:</mark></p><input type="number" id ="sphereX" max ="7" min="-7" value ="0" step = "0.5">
                </div> 
                <div>
                    <p> <mark>Y:</mark></p><input type="number" id ="sphereY" max ="7" min="-7" value ="0" step = "0.5">
                </div>
                <div>
                    <p> <mark>Z:</mark></p><input type="number" id ="sphereZ" max ="7" min="-7" value ="0" step = "0.5">
                </div>
                <div>
                    <p> <mark>Radius:</mark></p><input type="number" id ="sphereR" max ="2.0" min="0.3" value ="0.3">
                </div>
                 

          
       </div>
       <div class="col">
                    <div class="p-3 mb-2 bg-info text-dark">Set Color</div>
                     <!--RGB COLOR -->
                   <div>
                    <p> <mark>R:</mark></p>  <input type="number" id ="sphereR"  value ="50" min ="0" max = "255" step = "1.0">
                    </div> 
                    <div>
                        <p> <mark>G:</mark></p>  <input type="number" id ="sphereG"  value ="100" min ="0" max = "255" step = "1.0">
                    </div> 
                    <div>
                        <p> <mark>B:</mark></p>  <input type="number" id ="sphereB"  value ="50" min ="0" max = "255" step = "1.0">
                    </div> 
                   
               
       </div>
       <div class="col">
                <!--MATERIAL SETTING -->
                <div class="p-3 mb-2 bg-info text-dark">Set Materials</div>
                <p> <mark>Specular:</mark></p> <input type="number" id ="specular"  value ="0.4" min ="0" step = "0.1">
                <p> <mark>Diffuse: </mark></p><input type="number" id ="diffuse"  value ="0.7" min ="0" step = "0.1">
                <p> <mark>Reflection: </mark></p><input type="number" id ="reflection"  value ="0.4" min ="0" step = "0.1">
               <div>
                <button type="button"  class="btn btn-outline-success" onclick="addSphere()">Add Sphere</button>
               </div>
           
          
      
       </div>
   </div>

        </div>
            <div class="row">
                <div class="col">
                    <p>
                        <div>
                            <!--the mark is used to highlt the informations -->
                            <mark>Press A or D on your keyboard to change Camera X position</mark> 
                        </div>
                        <div>
                            <mark>Press W or S on your keyboard to change Camera Y position</mark> 
                        </div>
                        <div>
                            <mark>Mouse Scroll to change Camera Z position  </mark>
                        </div>
                        
                    </p>
                
                </div>

            </div>

        

        </div>
        
        
    </body>

</html>